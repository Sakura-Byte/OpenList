package sign

import (
	"crypto/hmac"
	"crypto/sha256"
	"encoding/base64"
	"encoding/json"
	"strings"
	"time"

	"github.com/OpenListTeam/OpenList/v4/internal/conf"
	"github.com/OpenListTeam/OpenList/v4/internal/model"
	"github.com/OpenListTeam/OpenList/v4/internal/op"
	"github.com/OpenListTeam/OpenList/v4/internal/setting"
	pkgSign "github.com/OpenListTeam/OpenList/v4/pkg/sign"
)

const downloadTokenPrefix = "v2."

type downloadPayload struct {
	Path string `json:"p"`
	User string `json:"u"`
	Exp  int64  `json:"e"`
}

func downloadSecret() []byte {
	return []byte(setting.GetStr(conf.Token) + "-download")
}

func downloadExpire() int64 {
	expire := setting.GetInt(conf.LinkExpiration, 0)
	if expire == 0 {
		return 0
	}
	return time.Now().Add(time.Duration(expire) * time.Hour).Unix()
}

func SignDownload(user *model.User, path string) string {
	username := ""
	if user != nil {
		username = user.Username
	}
	payload := downloadPayload{
		Path: path,
		User: username,
		Exp:  downloadExpire(),
	}
	data, _ := json.Marshal(payload)
	encPayload := base64.RawURLEncoding.EncodeToString(data)
	sig := signPayload(encPayload, downloadSecret())
	return downloadTokenPrefix + encPayload + "." + sig
}

func signPayload(payload string, secret []byte) string {
	h := hmac.New(sha256.New, secret)
	h.Write([]byte(payload))
	return base64.RawURLEncoding.EncodeToString(h.Sum(nil))
}

// VerifyDownload verifies download token and, when possible, returns the user encoded in the token.
// It remains backward-compatible with legacy path-only tokens generated by Verify.
func VerifyDownload(path, token string) (*model.User, error) {
	if strings.HasPrefix(token, downloadTokenPrefix) {
		return verifyDownloadV2(path, token)
	}
	return nil, Verify(path, token)
}

func verifyDownloadV2(path, token string) (*model.User, error) {
	token = strings.TrimPrefix(token, downloadTokenPrefix)
	parts := strings.Split(token, ".")
	if len(parts) != 2 {
		return nil, pkgSign.ErrSignInvalid
	}
	payloadEnc := parts[0]
	sig := parts[1]
	if !hmac.Equal([]byte(sig), []byte(signPayload(payloadEnc, downloadSecret()))) {
		return nil, pkgSign.ErrSignInvalid
	}
	payloadBytes, err := base64.RawURLEncoding.DecodeString(payloadEnc)
	if err != nil {
		return nil, pkgSign.ErrSignInvalid
	}
	var payload downloadPayload
	if err := json.Unmarshal(payloadBytes, &payload); err != nil {
		return nil, pkgSign.ErrSignInvalid
	}
	if payload.Path != path {
		return nil, pkgSign.ErrSignInvalid
	}
	if payload.Exp != 0 && payload.Exp < time.Now().Unix() {
		return nil, pkgSign.ErrSignExpired
	}
	if payload.User == "" {
		return nil, nil
	}
	user, err := op.GetUserByName(payload.User)
	if err != nil {
		return nil, nil
	}
	return user, nil
}
